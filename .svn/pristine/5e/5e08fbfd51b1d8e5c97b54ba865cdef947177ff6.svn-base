# -*- coding: utf-8 -*-
"""
Created on Fri Sep 20 22:50:45 2024

@author: addaio
"""

import flood_agents as FA
from flood_model import FloodModel
from flood_space import FloodArea

import mesa_geo as mg
from mesa.visualization import ModularServer
from mesa.visualization.modules import ChartModule, TextElement
from mesa.visualization import Slider

from mesa.batchrunner import batch_run
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd

import warnings
import time  # Import the time module
import psutil

# Suppress the specific FutureWarning
warnings.filterwarnings("ignore", category=FutureWarning, module="seaborn")

serverrun = False
batchrun = not serverrun

    # Function to get memory and CPU usage
def get_resource_usage():
    process = psutil.Process()
    memory_usage = process.memory_info().rss / (1024 ** 2)  # Convert to MB
    cpu_usage = process.cpu_percent(interval=None)  # CPU usage as a percentage
    return memory_usage, cpu_usage

if serverrun:

    #========================== Launch to server observe ======================
    
    # Define portrayal dictionary for different agents
    def agent_portrayal(agent):
        portrayal = {}
    
        # Custom portrayal for specific conditions
        if isinstance(agent, FA.Person_Agent):
            portrayal["color"] = "Green"
            portrayal["radius"] = "1"
            portrayal["fillOpacity"] = 1
            
            if agent.stranded:
                portrayal["color"] = "Red"
            elif not agent.alive:
                portrayal["color"] = "Black"
            elif agent.injured:
                portrayal["color"] = "Orange"
                
        elif isinstance(agent, FloodArea):
            portrayal["color"] = "Cyan"
            
        elif isinstance(agent, FA.Business_Agent):
            portrayal["color"] = "Purple"
    
        elif isinstance(agent, FA.House_Agent):
            portrayal["color"] = "Grey"
        
        elif isinstance(agent, FA.School_Agent):
            portrayal["color"] = "Yellow"
        
        elif isinstance(agent, FA.Shelter_Agent):
            portrayal["color"] = "Blue"
        
        elif isinstance(agent, FA.Healthcare_Agent):
            portrayal["color"] = "Orange"
        
        elif isinstance(agent, FA.Government_Agent):
            portrayal["color"] = "Magenta"   
        
        return portrayal
    
    
    class colorLegend(TextElement):
        def __init__(self):
            pass
    
        def render(self, model):
            # Define the legend content based on the agent portrayal colors and conditions
            legend = "<div style='position: absolute; right: 50px; top: 150px; font-size: 17px;'>"
            legend += "<strong>Legend:</strong><br>"
            legend += "<span style='color: green;'>&#9679; Green: Person<br>"
            legend += "<span style='color: red;'>&#9679; Red: Stranded Person<br>"
            legend += "<span style='color: orange;'>&#9679; Orange: Injured Person<br>"
            legend += "<span style='color: black;'>&#9679; Deceased Person<br>"
            legend += "<span style='color: purple;'>&#9679; Purple: Business<br>"
            legend += "<span style='color: grey;'>&#9679; Yellow: School<br>"
            legend += "<span style='color: brown;'>&#9679; Brown: House<br>"
            legend += "<span style='color: magenta;'>&#9679; Magenta: Government<br>"
            legend += "<span style='color: blue;'>&#9679; Blue: Shelter<br>"
            legend += "<span style='color: cyan;'>&#9679; Cyan: Healthcare<br>"
            legend += "</div>"      
            return legend
    
    model_params = {
        "N_persons": Slider("Number of persons", 300, 10, 1500, 10), #ini,min,max,stp
        "shelter_cap_limit": Slider("Shelter Capacity(% of pop.)", 1, 0, 10, 0.5),
        "healthcare_cap_limit": Slider("Healthcare Capacity(% of pop.)", 5, 0, 10, 1),
        "shelter_funding": Slider("Shelter funds $", 50000, 5000, 200000, 5000),
        "healthcare_funding": Slider("Healthcare funds $", 100000, 50000, 500000, 10000),
        "pre_flood_days": Slider("Pre Flood Days", 8, 0, 90, 1),
        "flood_days": Slider("Flood Days", 10, 3, 30, 1),
        "post_flood_days": Slider("Post Flood Days", 14, 0, 90, 1),
        "houses_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/houses.zip",
        "businesses_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/businesses.zip",
        "schools_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/schools.zip",
        "shelter_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/shelter.zip",
        "healthcare_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/healthcare.zip",
        "government_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/government.zip",
        "flood_file_1": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood1.zip",
        "flood_file_2": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood2.zip",
        "flood_file_3": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood3.zip",
        "model_crs": "EPSG:5070"
    }
    
    # Create a canvas grid with given portrayal function and agent dimensions
    map_element = mg.visualization.MapModule(agent_portrayal, map_height=500, map_width=860)
    # map_element = MapModule(agent_portrayal, map_height=500, map_width=860)
    
    # Add the legend to the visualization
    legend = colorLegend()
    
    #---------------------- SES index data visuals-----------------------------
    # Define a function to create SES-specific chart modules for decision-making phases
    def create_ses_charts(decision, ses_ranges):
        charts = []
        for ses_range in ses_ranges:
            charts.append(
                ChartModule([
                    {"Label": f"PMT_{decision}_{ses_range}", "Color": "blue"},
                    {"Label": f"TPB_{decision}_{ses_range}", "Color": "green"},
                    {"Label": f"SCT_{decision}_{ses_range}", "Color": "orange"},
                    {"Label": f"CRT_{decision}_{ses_range}", "Color": "red"}
                ])
            )
        return charts
    
    # Define SES ranges and their corresponding colors for each index
    ses_index_1_ranges = ['SES_1_0_0.4', 'SES_1_0.7_1']
    ses_index_2_ranges = ['SES_2_0_0.4', 'SES_2_0.7_1']
    all_ses_ranges = ses_index_1_ranges + ses_index_2_ranges
    ses_index_1_colors = ['green', 'red']
    ses_index_2_colors = ['blue', 'magenta']
    
    # Create SES-specific charts for decision phases
    preflood_non_evacuation_charts = create_ses_charts("preflood_non_evacuation_measure_implemented", all_ses_ranges)
    evacuation_charts = create_ses_charts("evacuation", all_ses_ranges)
    duringflood_coping_charts = create_ses_charts("duringflood_coping_action_implemented", all_ses_ranges)
    postflood_recovery_charts = create_ses_charts("postflood_adaptation_measures_planned", all_ses_ranges)
    
    # Define a function to create grouped SES charts for a given metric (e.g., Evacuated, Stranded)
    def create_grouped_ses_charts(metric, ses_ranges, colors):
        return ChartModule([
            {"Label": f"{metric}_{ses_range}", "Color": color} for ses_range, color in zip(ses_ranges, colors)
        ])
    
    # Create grouped charts for selected SES-based metrics for index 1 and index 2 separately
    evacuated_chart_ses_1 = create_grouped_ses_charts("evacuated", ses_index_1_ranges, ses_index_1_colors)
    evacuated_chart_ses_2 = create_grouped_ses_charts("evacuated", ses_index_2_ranges, ses_index_2_colors)
    
    stranded_chart_ses_1 = create_grouped_ses_charts("stranded", ses_index_1_ranges, ses_index_1_colors)
    stranded_chart_ses_2 = create_grouped_ses_charts("stranded", ses_index_2_ranges, ses_index_2_colors)
    
    injured_chart_ses_1 = create_grouped_ses_charts("injured", ses_index_1_ranges, ses_index_1_colors)
    injured_chart_ses_2 = create_grouped_ses_charts("injured", ses_index_2_ranges, ses_index_2_colors)
    
    sheltered_chart_ses_1 = create_grouped_ses_charts("sheltered", ses_index_1_ranges, ses_index_1_colors)
    sheltered_chart_ses_2 = create_grouped_ses_charts("sheltered", ses_index_2_ranges, ses_index_2_colors)
    
    hospitalized_chart_ses_1 = create_grouped_ses_charts("hospitalized", ses_index_1_ranges, ses_index_1_colors)
    hospitalized_chart_ses_2 = create_grouped_ses_charts("hospitalized", ses_index_2_ranges, ses_index_2_colors)
    
    dead_chart_ses_1 = create_grouped_ses_charts("dead", ses_index_1_ranges, ses_index_1_colors)
    dead_chart_ses_2 = create_grouped_ses_charts("dead", ses_index_2_ranges, ses_index_2_colors)
    
    # General charts (not SES-specific)
    persons_chart = ChartModule([
        {"Label": "Stranded", "Color": "red"},
        {"Label": "Injured", "Color": "orange"},
        {"Label": "Sheltered", "Color": "blue"},
        {"Label": "Hospitalized", "Color": "grey"},
        {"Label": "Death", "Color": "black"}
    ])
    
    decisions_chart = ChartModule([
        {"Label": "Preflood_Non_Evacuation_Measure_Implemented", "Color": "orange"},
        {"Label": "Evacuated", "Color": "green"},
        {"Label": "Duringflood_Coping_Action_Implemented", "Color": "red"},
        {"Label": "Postflood_Adaptation_Measures_Planned", "Color": "blue"}
    ])
    
    entities_chart = ChartModule([
        {"Label": "Houses_Flooded", "Color": "red"},
        {"Label": "Schools_Flooded", "Color": "orange"},
        {"Label": "Businesses_Flooded", "Color": "blue"}
    ])
    
    economic_chart = ChartModule([
        {"Label": "Wealth_People", "Color": "blue"},
        {"Label": "Wealth_Businesses", "Color": "green"},
        {"Label": "Wealth_Shelter", "Color": "orange"},
        {"Label": "Wealth_Healthcare", "Color": "purple"},
        {"Label": "Wealth_Government", "Color": "red"}
    ])
    
    # Combine all the chart modules into a single list
    all_charts = (
        [decisions_chart] + [persons_chart] + [entities_chart] + [economic_chart] + 
        preflood_non_evacuation_charts + evacuation_charts + duringflood_coping_charts + 
        postflood_recovery_charts + [evacuated_chart_ses_1, evacuated_chart_ses_2,
                                     stranded_chart_ses_1, stranded_chart_ses_2,
                                     injured_chart_ses_1, injured_chart_ses_2,
                                     sheltered_chart_ses_1, sheltered_chart_ses_2,
                                     hospitalized_chart_ses_1, hospitalized_chart_ses_2,
                                     dead_chart_ses_1, dead_chart_ses_2]
    )
    
    # Now you can pass all_charts to the server
    server = ModularServer(
        FloodModel,
        [map_element, legend] + all_charts,
        "Flood Model - Vulnerabilities and Decision Making",
        model_params,
    )
                
    # Run the server
    server.port = 8521  # The default port number
    server.launch()  

if batchrun:
    # =============================== BatchRun ================================
    
    # Start the timer
    start_time = time.time()
    
    # Measure resource usage before the run
    mem_before, cpu_before = get_resource_usage()
    print(f"Memory usage before batch run: {mem_before:.2f} MB")
    print(f"CPU usage before batch run: {cpu_before:.2f}%")
    
    batch_run_params = {
        "N_persons": [300],
        "shelter_cap_limit": [1],
        "healthcare_cap_limit": [5],
        "shelter_funding": [50000],
        "healthcare_funding": [100000],
        "pre_flood_days": [14],
        "flood_days": [10],
        "post_flood_days": [14],
        "houses_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/houses.zip",
        "businesses_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/businesses.zip",
        "schools_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/schools.zip",
        "shelter_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/shelter.zip",
        "healthcare_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/healthcare.zip",
        "government_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/government.zip",
        "flood_file_1": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood1.zip",
        "flood_file_2": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood2.zip",
        "flood_file_3": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood3.zip",
        "model_crs": "EPSG:5070"
        }
    
    num_iterations = 25
    
    # Create and run the batch
    results = batch_run(
        FloodModel, 
        batch_run_params, 
        iterations=num_iterations, 
        max_steps=24*38,  # Total number of steps the model will run in each iteration
        number_processes=1,  # Number of processes to use for parallel execution
        data_collection_period=1,  # Collect data at every step
        display_progress=True  # Display progress of the batch run
    )
    
    results_df = pd.DataFrame(results)
    
    # Convert "Step" from hours to days
    results_df["Step"] = results_df["Step"] / 24
    
    # Save the data
    results_df.to_csv("batch_run_results.csv", index=False)  # CSV
    results_df.to_pickle("batch_run_results.pkl")  # Pickle
    
    # Specify the columns you want to include in the analysis
    columns_to_include = [
        ["Step", "Evacuated", "Preflood_Non_Evacuation_Measure_Implemented", "Duringflood_Coping_Action_Implemented", "Postflood_Adaptation_Measures_Planned"],
        ["Step", "Stranded", "Injured", "Sheltered", "Hospitalized", "Death"],
        ["Step", "evacuated_SES_1_0_0.4", "evacuated_SES_1_0.7_1"],
        ["Step", "evacuated_SES_2_0_0.4", "evacuated_SES_2_0.7_1"],
        ["Step", "stranded_SES_1_0_0.4", "stranded_SES_1_0.7_1"],
        ["Step", "stranded_SES_2_0_0.4", "stranded_SES_2_0.7_1"],
        ["Step", "injured_SES_1_0_0.4", "injured_SES_1_0.7_1"],
        ["Step", "injured_SES_2_0_0.4", "injured_SES_2_0.7_1"],
        ["Step", "hospitalized_SES_1_0_0.4", "hospitalized_SES_1_0.7_1"],
        ["Step", "hospitalized_SES_2_0_0.4", "hospitalized_SES_2_0.7_1"],
        ["Step", "sheltered_SES_1_0_0.4", "sheltered_SES_1_0.7_1"],
        ["Step", "sheltered_SES_2_0_0.4", "sheltered_SES_2_0.7_1"],
        ["Step", "dead_SES_1_0_0.4", "dead_SES_1_0.7_1"],
        ["Step", "dead_SES_2_0_0.4", "dead_SES_2_0.7_1"],
        ["Step", "Houses_Flooded", "Businesses_Flooded", "Schools_Flooded"],
        ["Step", "Wealth_People", "Wealth_Businesses", "Wealth_Shelter", "Wealth_Healthcare", "Wealth_Government"],
        ["Step", "PMT_preflood_non_evacuation_measure_implemented_SES_1_0_0.4",	"TPB_preflood_non_evacuation_measure_implemented_SES_1_0_0.4", "SCT_preflood_non_evacuation_measure_implemented_SES_1_0_0.4",	"CRT_preflood_non_evacuation_measure_implemented_SES_1_0_0.4"],
        ["Step", "PMT_preflood_non_evacuation_measure_implemented_SES_1_0.7_1", "TPB_preflood_non_evacuation_measure_implemented_SES_1_0.7_1", "SCT_preflood_non_evacuation_measure_implemented_SES_1_0.7_1",	"CRT_preflood_non_evacuation_measure_implemented_SES_1_0.7_1"],
        ["Step", "PMT_preflood_non_evacuation_measure_implemented_SES_2_0_0.4",	"TPB_preflood_non_evacuation_measure_implemented_SES_2_0_0.4", "SCT_preflood_non_evacuation_measure_implemented_SES_2_0_0.4",	"CRT_preflood_non_evacuation_measure_implemented_SES_2_0_0.4"],
        ["Step", "PMT_preflood_non_evacuation_measure_implemented_SES_2_0.7_1", "TPB_preflood_non_evacuation_measure_implemented_SES_2_0.7_1", "SCT_preflood_non_evacuation_measure_implemented_SES_2_0.7_1",	"CRT_preflood_non_evacuation_measure_implemented_SES_2_0.7_1"],
        ["Step", "PMT_evacuation_SES_1_0_0.4", "TPB_evacuation_SES_1_0_0.4", "SCT_evacuation_SES_1_0_0.4",	"CRT_evacuation_SES_1_0_0.4"],
        ["Step", "PMT_evacuation_SES_1_0.7_1", "TPB_evacuation_SES_1_0.7_1", "SCT_evacuation_SES_1_0.7_1",	"CRT_evacuation_SES_1_0.7_1"],
        ["Step", "PMT_evacuation_SES_2_0_0.4", "TPB_evacuation_SES_2_0_0.4", "SCT_evacuation_SES_2_0_0.4",	"CRT_evacuation_SES_2_0_0.4"],
        ["Step", "PMT_evacuation_SES_2_0.7_1", "TPB_evacuation_SES_2_0.7_1", "SCT_evacuation_SES_2_0.7_1",	"CRT_evacuation_SES_2_0.7_1"],
        ["Step", "PMT_duringflood_coping_action_implemented_SES_1_0_0.4", "TPB_duringflood_coping_action_implemented_SES_1_0_0.4", "SCT_duringflood_coping_action_implemented_SES_1_0_0.4",	"CRT_duringflood_coping_action_implemented_SES_1_0_0.4"],
        ["Step", "PMT_duringflood_coping_action_implemented_SES_1_0.7_1", "TPB_duringflood_coping_action_implemented_SES_1_0.7_1", "SCT_duringflood_coping_action_implemented_SES_1_0.7_1",	"CRT_duringflood_coping_action_implemented_SES_1_0.7_1"],
        ["Step", "PMT_duringflood_coping_action_implemented_SES_2_0_0.4", "TPB_duringflood_coping_action_implemented_SES_2_0_0.4", "SCT_duringflood_coping_action_implemented_SES_2_0_0.4",	"CRT_duringflood_coping_action_implemented_SES_2_0_0.4"],
        ["Step", "PMT_duringflood_coping_action_implemented_SES_2_0.7_1", "TPB_duringflood_coping_action_implemented_SES_2_0.7_1", "SCT_duringflood_coping_action_implemented_SES_2_0.7_1",	"CRT_duringflood_coping_action_implemented_SES_2_0.7_1"],
        ["Step", "PMT_postflood_adaptation_measures_planned_SES_1_0_0.4", "TPB_postflood_adaptation_measures_planned_SES_1_0_0.4", "SCT_postflood_adaptation_measures_planned_SES_1_0_0.4",	"CRT_postflood_adaptation_measures_planned_SES_1_0_0.4"],
        ["Step", "PMT_postflood_adaptation_measures_planned_SES_1_0.7_1", "TPB_postflood_adaptation_measures_planned_SES_1_0.7_1", "SCT_postflood_adaptation_measures_planned_SES_1_0.7_1",	"CRT_postflood_adaptation_measures_planned_SES_1_0.7_1"],
        ["Step", "PMT_postflood_adaptation_measures_planned_SES_2_0_0.4", "TPB_postflood_adaptation_measures_planned_SES_2_0_0.4", "SCT_postflood_adaptation_measures_planned_SES_2_0_0.4",	"CRT_postflood_adaptation_measures_planned_SES_2_0_0.4"],
        ["Step", "PMT_postflood_adaptation_measures_planned_SES_2_0.7_1", "TPB_postflood_adaptation_measures_planned_SES_2_0.7_1", "SCT_postflood_adaptation_measures_planned_SES_2_0.7_1",	"CRT_postflood_adaptation_measures_planned_SES_2_0.7_1"]
    ]
    
    #======================== Plot batch run results =========================#
    # Filter only the numeric columns and group by the "Step" column
    for i, group_columns in enumerate(columns_to_include):
        numeric_data = results_df[group_columns].select_dtypes(include='number')
    
        # Replace infinite values with NaN
        numeric_data.replace([np.inf, -np.inf], np.nan, inplace=True)
    
        # Group by the "Step" column
        grouped_data = numeric_data.groupby("Step")
        
        # Calculate the mean, minimum, and maximum for each group
        average_data = grouped_data.mean()
        std_data = grouped_data.std()
        
        # Define the x-tick intervals (every 7 days)
        xticks = np.arange(0, max(average_data.index) + 1, 7)
        
        # Create a lineplot with error bars for each column in the group
        plt.figure(figsize=(10, 6))
        for column in group_columns[1:]:
            g = sns.lineplot(
                data=average_data,
                x="Step",
                y=column,
                label=column,
            )
            # Fill between the mean +/- standard deviation
            plt.fill_between(average_data.index, average_data[column] - std_data[column], average_data[column] + std_data[column], alpha=0.2)
                    
        # plt.title(f"Group {i+1}")
        plt.xlabel("Days")
        plt.xticks(xticks)  # Set x-axis to display ticks every 7 days
        plt.legend()
        plt.show()  
        
        # Create a lineplot without error bars for each column in the group
        plt.figure(figsize=(10, 6))
        for column in group_columns[1:]:
            g = sns.lineplot(
                data=average_data,
                x="Step",
                y=column,
                label=column,
            )
                        
        # plt.title(f"Group {i+1}")
        plt.xlabel("Days")
        plt.xticks(xticks)  # Set x-axis to display ticks every 7 days
        plt.legend()
        plt.show()   
    
# Measure resource usage after the run
mem_after, cpu_after = get_resource_usage()
print(f"Memory usage after batch run: {mem_after:.2f} MB")
print(f"CPU usage after batch run: {cpu_after:.2f}%")
  
# Elapsed time calculation
end_time = time.time()
elapsed_time = (end_time - start_time) / 60
print(f"Batch run completed in {elapsed_time:.2f} minutes.")
print(f"Total memory used: {mem_after - mem_before:.2f} MB")

    
    
    