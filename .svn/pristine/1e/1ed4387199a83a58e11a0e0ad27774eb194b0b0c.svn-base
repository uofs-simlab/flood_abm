# -*- coding: utf-8 -*-

# Version changes - using mesa-geo for gis

"""
Created on Fri Dec 29 17:53:04 2023
@author: oaadd
"""
import flood_agents as FA
from flood_model import FloodModel
from flood_space import FloodArea

import mesa_geo as mg
from mesa.visualization import ModularServer
from mesa.visualization.modules import ChartModule, TextElement
from mesa.visualization import Slider

from mesa.batchrunner import batch_run
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import pandas as pd

import warnings
import time  # Import the time module
import psutil

# Suppress the specific FutureWarning
warnings.filterwarnings("ignore", category=FutureWarning, module="seaborn")

serverrun = True
batchrun = not serverrun

    # Function to get memory and CPU usage
def get_resource_usage():
    process = psutil.Process()
    memory_usage = process.memory_info().rss / (1024 ** 2)  # Convert to MB
    cpu_usage = process.cpu_percent(interval=None)  # CPU usage as a percentage
    return memory_usage, cpu_usage

if serverrun:

    #========================== Launch to server observe ======================
    
    # Define portrayal dictionary for different agents
    def agent_portrayal(agent):
        portrayal = {}
    
        # Custom portrayal for specific conditions
        if isinstance(agent, FA.Person_Agent):
            portrayal["color"] = "Green"
            portrayal["radius"] = "1"
            portrayal["fillOpacity"] = 1
            
            if agent.stranded:
                portrayal["color"] = "Red"
            elif not agent.alive:
                portrayal["color"] = "Black"
            elif agent.injured:
                portrayal["color"] = "Orange"
                
        elif isinstance(agent, FloodArea):
            portrayal["color"] = "Cyan"
            
        elif isinstance(agent, FA.Business_Agent):
            portrayal["color"] = "Purple"
    
        elif isinstance(agent, FA.House_Agent):
            portrayal["color"] = "Grey"
        
        elif isinstance(agent, FA.School_Agent):
            portrayal["color"] = "Yellow"
        
        elif isinstance(agent, FA.Shelter_Agent):
            portrayal["color"] = "Blue"
        
        elif isinstance(agent, FA.Healthcare_Agent):
            portrayal["color"] = "Orange"
        
        elif isinstance(agent, FA.Government_Agent):
            portrayal["color"] = "Magenta"   
        
        return portrayal
    
    
    class colorLegend(TextElement):
        def __init__(self):
            pass
    
        def render(self, model):
            # Define the legend content based on the agent portrayal colors and conditions
            legend = "<div style='position: absolute; right: 50px; top: 150px; font-size: 17px;'>"
            legend += "<strong>Legend:</strong><br>"
            legend += "<span style='color: green;'>&#9679; Green: Person<br>"
            legend += "<span style='color: red;'>&#9679; Red: Stranded Person<br>"
            legend += "<span style='color: orange;'>&#9679; Orange: Injured Person<br>"
            legend += "<span style='color: black;'>&#9679; Deceased Person<br>"
            legend += "<span style='color: purple;'>&#9679; Purple: Business<br>"
            legend += "<span style='color: grey;'>&#9679; Yellow: School<br>"
            legend += "<span style='color: brown;'>&#9679; Brown: House<br>"
            legend += "<span style='color: magenta;'>&#9679; Magenta: Government<br>"
            legend += "<span style='color: blue;'>&#9679; Blue: Shelter<br>"
            legend += "<span style='color: cyan;'>&#9679; Cyan: Healthcare<br>"
            legend += "</div>"      
            return legend
    
    model_params = {
        "N_persons": Slider("Number of persons", 300, 10, 500, 10), #ini,min,max,stp
        "shelter_cap_limit": Slider("Shelter Capacity(% of pop.)", 1, 0, 100, 0.5),
        "healthcare_cap_limit": Slider("Healthcare Capacity(% of pop.)", 5, 0, 100, 1),
        "shelter_funding": Slider("Shelter funds $", 50000, 5000, 200000, 5000),
        "healthcare_funding": Slider("Healthcare funds $", 100000, 50000, 500000, 10000),
        "pre_flood_days": Slider("Pre Flood Days", 10, 0, 90, 1),
        "flood_days": Slider("Flood Days", 10, 3, 30, 1),
        "post_flood_days": Slider("Post Flood Days", 14, 0, 90, 1),
        "houses_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/houses.zip",
        "businesses_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/businesses.zip",
        "schools_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/schools.zip",
        "shelter_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/shelter.zip",
        "healthcare_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/healthcare.zip",
        "government_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/government.zip",
        "flood_file_1": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood1.zip",
        "flood_file_2": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood2.zip",
        "flood_file_3": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood3.zip",
        "model_crs": "EPSG:5070"
    }
    
    # Create a canvas grid with given portrayal function and agent dimensions
    map_element = mg.visualization.MapModule(agent_portrayal, map_height=500, map_width=860)
    
    # Add the legend to the visualization
    legend = colorLegend()
    
    
    #---------------------- SES index data visuals-----------------------------
    
    # Define ChartModules for stranded persons by ethnicity, economy class, age categories, and dead agents
    
    preflood_mitigation_chart = ChartModule([
        {"Label": "PMT_preflood_mitigation_non_evac_False", "Color": "red"},
        {"Label": "PMT_preflood_mitigation_non_evac_True", "Color": "orange"},
        {"Label": "TPB_preflood_mitigation_non_evac_True", "Color": "blue"},
        {"Label": "TPB_preflood_mitigation_non_evac_False", "Color": "grey"},
        {"Label": "SCT_preflood_mitigation_non_evac_True", "Color": "black"},
        {"Label": "SCT_preflood_mitigation_non_evac_False", "Color": "green"},
        {"Label": "CRT_preflood_mitigation_non_evac_True", "Color": "cyan"},
        {"Label": "CRT_preflood_mitigation_non_evac_False", "Color": "brown"},
        ])
    
    preflood_evac_chart = ChartModule([
        {"Label": "PMT_preflood_evac_False", "Color": "red"},
        {"Label": "PMT_preflood_evac_True", "Color": "orange"},
        {"Label": "TPB_preflood_evac_True", "Color": "blue"},
        {"Label": "TPB_preflood_evac_False", "Color": "grey"},
        {"Label": "SCT_preflood_evac_True", "Color": "black"},
        {"Label": "SCT_preflood_evac_False", "Color": "green"},
        {"Label": "CRT_preflood_evac_True", "Color": "cyan"},
        {"Label": "CRT_preflood_evac_False", "Color": "brown"},
        ])
    
    duringflood_evac_chart = ChartModule([
        {"Label": "PMT_duringflood_evac_False", "Color": "red"},
        {"Label": "PMT_duringflood_evac_True", "Color": "orange"},
        {"Label": "TPB_duringflood_evac_True", "Color": "blue"},
        {"Label": "TPB_duringflood_evac_False", "Color": "grey"},
        {"Label": "SCT_duringflood_evac_True", "Color": "black"},
        {"Label": "SCT_duringflood_evac_False", "Color": "green"},
        {"Label": "CRT_duringflood_evac_True", "Color": "cyan"},
        {"Label": "CRT_duringflood_evac_False", "Color": "brown"},
        ])
    
    duringflood_coping_chart = ChartModule([
        {"Label": "PMT_duringflood_coping_False", "Color": "red"},
        {"Label": "PMT_duringflood_coping_True", "Color": "orange"},
        {"Label": "TPB_duringflood_coping_True", "Color": "blue"},
        {"Label": "TPB_duringflood_coping_False", "Color": "grey"},
        {"Label": "SCT_duringflood_coping_True", "Color": "black"},
        {"Label": "SCT_duringflood_coping_False", "Color": "green"},
        {"Label": "CRT_duringflood_coping_True", "Color": "cyan"},
        {"Label": "CRT_duringflood_coping_False", "Color": "brown"},
        ])
        
    postflood_recovery_chart = ChartModule([
        {"Label": "PMT_postflood_recovery_False", "Color": "red"},
        {"Label": "PMT_postflood_recovery_True", "Color": "orange"},
        {"Label": "TPB_postflood_recovery_True", "Color": "blue"},
        {"Label": "TPB_postflood_recovery_False", "Color": "grey"},
        {"Label": "SCT_postflood_recovery_True", "Color": "black"},
        {"Label": "SCT_postflood_recovery_False", "Color": "green"},
        {"Label": "CRT_postflood_recovery_True", "Color": "cyan"},
        {"Label": "CRT_postflood_recovery_False", "Color": "brown"},
        ])
    
    persons_chart = ChartModule([
        {"Label": "Stranded", "Color": "red"},
        {"Label": "Injured", "Color": "orange"},
        {"Label": "Sheltered", "Color": "blue"},
        {"Label": "Hospitalized", "Color": "grey"},
        {"Label": "Death", "Color": "black"},
    ])
    
    decisions_chart = ChartModule([    
        {"Label": "Preflood_Non_Evacuation_Measure_Implemented", "Color": "orange"},
        {"Label": "Evacuated", "Color": "green"},
        {"Label": "Duringflood_Coping_Action_Implemented", "Color": "red"},
        {"Label": "Postflood_Adaptation_Measures_Planned", "Color": "blue"},
    ])
    
    entities_chart = ChartModule([
        {"Label": "Houses_Flooded", "Color": "red"},
        {"Label": "Schools_Flooded", "Color": "orange"},
        {"Label": "Businesses_Flooded", "Color": "blue"},
    ])
    
    economic_chart = ChartModule([
        {"Label": "Wealth_People", "Color": "blue"},
        {"Label": "Wealth_Businesses", "Color": "green"},
        {"Label": "Wealth_Shelter", "Color": "orange"},
        {"Label": "Wealth_Healthcare", "Color": "purple"},
        {"Label": "Wealth_Government", "Color": "red"},
    ])
    
    def create_chart_modules(label_prefix, categories, colors):
        return [
            ChartModule([{"Label": f"{label_prefix}_{category}", "Color": color} for category, color in zip(categories, colors)])
        ] 
    
    # Define categories and their corresponding colors
    ses_index_1_ranges = ['SES_index_1_0_0.25', 'SES_index_1_0.25_0.5', 'SES_index_1_0.5_0.75', 'SES_index_1_0.75_1']
    ses_index_2_ranges = ['SES_index_2_0_0.25', 'SES_index_2_0.25_0.5', 'SES_index_2_0.5_0.75', 'SES_index_2_0.75_1']
    
    # Define colors for each category
    ses_index_1_colors = ['green', 'blue', 'orange', 'red']
    ses_index_2_colors = ['green', 'cyan', 'orange', 'magenta']
    
    # Create ChartModules
    
    chart_modules = create_chart_modules("Evacuated", ses_index_1_ranges, ses_index_1_colors) + \
                    create_chart_modules("Evacuated", ses_index_2_ranges, ses_index_2_colors) + \
                    create_chart_modules("Stranded", ses_index_1_ranges, ses_index_1_colors) + \
                    create_chart_modules("Stranded", ses_index_2_ranges, ses_index_2_colors) + \
                    create_chart_modules("Rescued", ses_index_1_ranges, ses_index_1_colors) + \
                    create_chart_modules("Rescued", ses_index_2_ranges, ses_index_2_colors) + \
                    create_chart_modules("Injured", ses_index_1_ranges, ses_index_1_colors) + \
                    create_chart_modules("Injured", ses_index_2_ranges, ses_index_2_colors) + \
                    create_chart_modules("Hospitalized", ses_index_1_ranges, ses_index_1_colors) + \
                    create_chart_modules("Hospitalized", ses_index_2_ranges, ses_index_2_colors) + \
                    create_chart_modules("Dead", ses_index_1_ranges, ses_index_1_colors) + \
                    create_chart_modules("Dead", ses_index_2_ranges, ses_index_2_colors) + \
                    [entities_chart] + [economic_chart]
    
    # Create a ModularServer and visualize the model including all ChartModules
    server = ModularServer(
        FloodModel,
        [map_element, legend, decisions_chart] + [preflood_mitigation_chart] + [preflood_evac_chart] + [duringflood_evac_chart] +
        [duringflood_coping_chart] + [postflood_recovery_chart] + [persons_chart] + chart_modules,
        "Flood Model - Ethnicity, Economy Class, Age Categories, and Dead Agents",
        model_params,
    )
                
    # Run the server
    server.port = 8521  # The default port number
    server.launch()  

if batchrun:
    # =============================== BatchRun ================================
    
    # Start the timer
    start_time = time.time()
    
    # Measure resource usage before the run
    mem_before, cpu_before = get_resource_usage()
    print(f"Memory usage before batch run: {mem_before:.2f} MB")
    print(f"CPU usage before batch run: {cpu_before:.2f}%")

    
    batch_run_params = {
        "N_persons": [300],
        "shelter_cap_limit": [1],
        "healthcare_cap_limit": [5],
        "shelter_funding": [50000],
        "healthcare_funding": [100000],
        "pre_flood_days": [14],
        "flood_days": [10],
        "post_flood_days": [14],
        "houses_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/houses.zip",
        "businesses_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/businesses.zip",
        "schools_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/schools.zip",
        "shelter_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/shelter.zip",
        "healthcare_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/healthcare.zip",
        "government_file": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/government.zip",
        "flood_file_1": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood1.zip",
        "flood_file_2": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood2.zip",
        "flood_file_3": "C:/Users/addaio/Desktop/labwork/flood_abm/calgary_map_data/flood3.zip",
        "model_crs": "EPSG:5070"
        }
    
    num_iterations = 1
    
    # Create and run the batch
    results = batch_run(
        FloodModel, 
        batch_run_params, 
        iterations=num_iterations, 
        max_steps=24*38,  # Total number of steps the model will run in each iteration
        number_processes=1,  # Number of processes to use for parallel execution
        data_collection_period=1,  # Collect data at every step
        display_progress=True  # Display progress of the batch run
    )
    
    results_df = pd.DataFrame(results)
    
    # Convert "Step" from hours to days
    results_df["Step"] = results_df["Step"] / 24
    
    # Specify the columns you want to include in the analysis
    columns_to_include = [
        ["Step", "Evacuated", "Preflood_Non_Evacuation_Measure_Implemented", "Duringflood_Coping_Action_Implemented", "Postflood_Adaptation_Measures_Planned"],
        ["Step", "Evacuated_SES_index_1_0_0.25", "Evacuated_SES_index_1_0.25_0.5", "Evacuated_SES_index_1_0.5_0.75", "Evacuated_SES_index_1_0.75_1"],
        ["Step", "Evacuated_SES_index_2_0_0.25", "Evacuated_SES_index_2_0.25_0.5", "Evacuated_SES_index_2_0.5_0.75", "Evacuated_SES_index_2_0.75_1"],
        ["Step", "Stranded", "Injured", "Sheltered", "Hospitalized", "Death"],
        ["Step", "Stranded_SES_index_1_0_0.25", "Stranded_SES_index_1_0.25_0.5", "Stranded_SES_index_1_0.5_0.75", "Stranded_SES_index_1_0.75_1"],
        ["Step", "Stranded_SES_index_2_0_0.25", "Stranded_SES_index_2_0.25_0.5", "Stranded_SES_index_2_0.5_0.75", "Stranded_SES_index_2_0.75_1"],
        ["Step", "Injured_SES_index_1_0_0.25", "Injured_SES_index_1_0.25_0.5", "Injured_SES_index_1_0.5_0.75", "Injured_SES_index_1_0.75_1"],
        ["Step", "Injured_SES_index_2_0_0.25", "Injured_SES_index_2_0.25_0.5", "Injured_SES_index_2_0.5_0.75", "Injured_SES_index_2_0.75_1"],
        ["Step", "Hospitalized_SES_index_1_0_0.25", "Hospitalized_SES_index_1_0.25_0.5", "Hospitalized_SES_index_1_0.5_0.75", "Hospitalized_SES_index_1_0.75_1"],
        ["Step", "Hospitalized_SES_index_2_0_0.25", "Hospitalized_SES_index_2_0.25_0.5", "Hospitalized_SES_index_2_0.5_0.75", "Hospitalized_SES_index_2_0.75_1"],
        ["Step", "Rescued_SES_index_1_0_0.25", "Rescued_SES_index_1_0.25_0.5", "Rescued_SES_index_1_0.5_0.75", "Rescued_SES_index_1_0.75_1"],
        ["Step", "Rescued_SES_index_2_0_0.25", "Rescued_SES_index_2_0.25_0.5", "Rescued_SES_index_2_0.5_0.75", "Rescued_SES_index_2_0.75_1"],
        ["Step", "Dead_SES_index_1_0_0.25", "Dead_SES_index_1_0.25_0.5", "Dead_SES_index_1_0.5_0.75", "Dead_SES_index_1_0.75_1"],
        ["Step", "Dead_SES_index_2_0_0.25", "Dead_SES_index_2_0.25_0.5", "Dead_SES_index_2_0.5_0.75", "Dead_SES_index_2_0.75_1"],
        ["Step", "Houses_Flooded", "Businesses_Flooded", "Schools_Flooded"],
        ["Step", "Wealth_People", "Wealth_Businesses", "Wealth_Shelter", "Wealth_Healthcare", "Wealth_Government"],
        ["Step", "PMT_preflood_mitigation_non_evac_True", "TPB_preflood_mitigation_non_evac_True", "SCT_preflood_mitigation_non_evac_True", "CRT_preflood_mitigation_non_evac_True"],
        ["Step", "PMT_preflood_mitigation_non_evac_False", "TPB_preflood_mitigation_non_evac_False", "SCT_preflood_mitigation_non_evac_False", "CRT_preflood_mitigation_non_evac_False"],
        ["Step", "PMT_preflood_evac_True", "TPB_preflood_evac_True", "SCT_preflood_evac_True", "CRT_preflood_evac_True", ],
        ["Step", "PMT_preflood_evac_False", "TPB_preflood_evac_False", "SCT_preflood_evac_False", "CRT_preflood_evac_False"],
        ["Step", "PMT_duringflood_evac_True", "TPB_duringflood_evac_True", "SCT_duringflood_evac_True", "CRT_duringflood_evac_True"],
        ["Step", "PMT_duringflood_evac_False", "TPB_duringflood_evac_False", "SCT_duringflood_evac_False", "CRT_duringflood_evac_False"],
        ["Step", "PMT_duringflood_coping_True", "TPB_duringflood_coping_True", "SCT_duringflood_coping_True", "CRT_duringflood_coping_True"],
        ["Step", "PMT_duringflood_coping_False", "TPB_duringflood_coping_False", "SCT_duringflood_coping_False", "CRT_duringflood_coping_False"],
        ["Step", "PMT_postflood_recovery_True", "TPB_postflood_recovery_True", "SCT_postflood_recovery_True", "CRT_postflood_recovery_True"],
        ["Step", "PMT_postflood_recovery_False", "TPB_postflood_recovery_False", "SCT_postflood_recovery_False", "CRT_postflood_recovery_False"]
    ] 
    
    #========================= Collect the avg and std ========================
    
    # combined_data = pd.DataFrame()

    # for i, group_columns in enumerate(columns_to_include):
    #     numeric_data = results_df[group_columns].select_dtypes(include='number')
    
    #     # Replace infinite values with NaN
    #     numeric_data.replace([np.inf, -np.inf], np.nan, inplace=True)
    
    #     # Group by the "Step" column
    #     grouped_data = numeric_data.groupby("Step")
        
    #     # Calculate the mean for each group
    #     average_data = grouped_data.mean()
        
    #     # Optionally, add a prefix to the column names to avoid duplicates
    #     average_data.columns = [f'{col}' for col in average_data.columns]
        
    #     # Concatenate the average_data DataFrame to the combined_data DataFrame
    #     if combined_data.empty:
    #         combined_data = average_data
    #     else:
    #         combined_data = pd.concat([combined_data, average_data], axis=1)
            
    # # Insert the "Run_1" column
    # combined_data.insert(0, 'Run_1', combined_data.index)
    
    # # Save the combined data to a single Excel sheet
    # combined_data.to_excel('average_data.xlsx', sheet_name='AverageData')
    
    # print('All data saved to average_data.xlsx')
    
    #======================== Plot batch run results =========================#
    # Filter only the numeric columns and group by the "Step" column
    for i, group_columns in enumerate(columns_to_include):
        numeric_data = results_df[group_columns].select_dtypes(include='number')
    
        # Replace infinite values with NaN
        numeric_data.replace([np.inf, -np.inf], np.nan, inplace=True)
    
        # Group by the "Step" column
        grouped_data = numeric_data.groupby("Step")
        
        # Calculate the mean, minimum, and maximum for each group
        average_data = grouped_data.mean()
        std_data = grouped_data.std()
        
        # Create a lineplot with error bars for each column in the group
        plt.figure(figsize=(10, 6))
        for column in group_columns[1:]:
            g = sns.lineplot(
                data=average_data,
                x="Step",
                y=column,
                label=column,
            )
            # Fill between the mean +/- standard deviation
            plt.fill_between(average_data.index, average_data[column] - std_data[column], average_data[column] + std_data[column], alpha=0.2)
                    
        # plt.title(f"Group {i+1}")
        plt.xlabel("Days")
        plt.ylabel("%age pop. wrt vul. grp")
        plt.legend()
        plt.show()    
    
# Measure resource usage after the run
mem_after, cpu_after = get_resource_usage()
print(f"Memory usage after batch run: {mem_after:.2f} MB")
print(f"CPU usage after batch run: {cpu_after:.2f}%")
  
# Elapsed time calculation
end_time = time.time()
elapsed_time = (end_time - start_time) / 60
print(f"Batch run completed in {elapsed_time:.2f} minutes.")
print(f"Total memory used: {mem_after - mem_before:.2f} MB")

    
    
