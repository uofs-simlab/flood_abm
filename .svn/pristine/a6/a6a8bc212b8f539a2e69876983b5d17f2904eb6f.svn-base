# Version changes
#   Education is just yes or no

#Libraries
import random


############################################################### STEP (DAY) ########################################################################
def step(self):
    # if self.disaster_period in ['pre_flood_evac_period', 'during_flood', 'post_flood']: # Check if the current disaster period is one of the specified periods
    adjust_for_location(self)
    adjust_factors_based_on_demographics_and_identity(self)
    update_severity(self)
    update_response_efficacy(self)
    update_self_efficacy(self)
    update_perceived_costs(self)
    update_SCT(self)
    decide_on_action(self)
        
        
############################################################ DECISION-MAKING (NATURAL DISASTER) ####################################################
# Support methods - Updates for every step

def adjust_for_location(self):
    # Adjust threat level and coping potential based on location
    if self.is_high_risk_area == 1:
        self.severity *= 1.2 + add_randomness()
        self.vulnerability *= 1.1 + add_randomness()
    else:
        self.severity *= 0.8 + add_randomness()
        self.vulnerability *= 0.9 + add_randomness()

def adjust_factors_based_on_demographics_and_identity(self):
    if self.age > 65:
        self.severity *= 1.1 + add_randomness()  
    if self.education > 0.6 :
        self.severity *= 1.05 + add_randomness() 
        self.response_efficacy *= 1.05 + add_randomness() 
    if self.wealth_class == "Lower_Class":
        self.costs *= 1.2  + add_randomness()
    if self.gender == 'Female':
        self.costs *= 1.2 + add_randomness()
    if self.ethnicity == 'Indigenous':
        self.costs *= 1.1 + add_randomness()

def update_severity(self):
    base_severity = 0.5 + add_randomness()
    past_experience_influence = 0.1 * self.past_experience + add_randomness()
    location_influence = 0.2 if self.is_high_risk_area == 1 else -0.1

    severity = base_severity + past_experience_influence + location_influence + add_randomness()
    self.severity = max(0, min(severity, 1))

def update_response_efficacy(self):
    weights = [0.5, 0.5, 0.3, 0.2] 
    self.response_efficacy = (self.trust_in_authorities * weights[0] +
                                self.media_trust * weights[1] +
                                self.self_efficacy * weights[2] +
                                self.past_experience * weights[3]) + add_randomness()
    
def update_self_efficacy(self):
    base_self_efficacy = 0.5
    # Factors influencing self-efficacy
    past_experience_influence = 0.3 * self.past_experience + add_randomness()
    social_support_influence = 0.2 * self.bonding_count + add_randomness()

    self_efficacy = base_self_efficacy + past_experience_influence + social_support_influence + add_randomness()
    self.self_efficacy =  max(0, min(self_efficacy, 1)) 

def update_perceived_costs(self):
    base_costs = 0.5
    income_influence = -0.05 if self.wealth_class in ("Upper_Middle_Class", "Upper_Class") else 0.05
    education_influence = -0.025 if self.education > 0.7 else 0.025
    social_support = -0.05 if self.bonding_count > 0.3 else 0.05
    past_experience_influence = 0.1 if self.past_experience > 0.5 else -0.05

    influences_sum = income_influence + education_influence + social_support + past_experience_influence + + add_randomness()
    influences_sum = max(-0.5, min(influences_sum, 0.5))

    perceived_costs = base_costs + influences_sum + add_randomness()
    perceived_costs = max(0, min(perceived_costs, 1))
    self.costs = perceived_costs + add_randomness()

def update_SCT(self):
    if self.bonding_count > 0.7 :
        self.social_capital_score += 0.2 + add_randomness()
    else:
        self.social_capital_score -= 0.2 + add_randomness()

    if self.bridging_count > 0.5:
        self.social_capital_score += 0.2 + add_randomness()
    else:
        self.social_capital_score -= 0.2 + add_randomness()

    if self.linking_count  > 0.3:
        self.social_capital_score += 0.2 + add_randomness()
    else:
        self.social_capital_score -= 0.2 + add_randomness()

    if self.social_trust == 1:
        self.social_capital_score += 0.2 + add_randomness()
    else:
        self.social_capital_score -= 0.2 + add_randomness()
        
def decide_on_action(self):
     """
     Execute the selected decision-making process to determine the agent's actions.
     """
     select_decision_making_process(self)
              


##### DECISION MAKING FOR - PRE, DURING AND POST FLOOD EVENTS    

def select_decision_making_process(self):
    """
    Select the decision-making process based on the agent's attributes

    -Protection Motivation Theory (PMT)
    -Social Capital Theory (SCT)
    -Cultural Risk Theory (CRT)
    -Theory of Planned Behavior (TPB)
    """
    # Define the mapping for decision-making functions
    decision_making_functions = {
    'pre_flood_evac_period': {
        'evacuation': {
            'CRT': lambda: CRT_decide_on_evacuation(self),
            'SCT': lambda: SCT_decide_on_evacuation(self),
            'TPB': lambda: TPB_decide_on_evacuation(self),
            'PMT': lambda: PMT_decide_on_evacuation(self)
        },
        'mitigation_preparedness': {
            'CRT': lambda: CRT_decide_on_mitigation_and_preparedness(self),
            'SCT': lambda: SCT_decide_on_mitigation_and_preparedness(self),
            'TPB': lambda: TPB_decide_on_mitigation_and_preparedness(self),
            'PMT': lambda: PMT_decide_on_mitigation_and_preparedness(self)
        }
    },
    'during_flood': {
        
        'evacuation': {
            'CRT': lambda: CRT_decide_on_evacuation(self),
            'SCT': lambda: SCT_decide_on_evacuation(self),
            'TPB': lambda: TPB_decide_on_evacuation(self),
            'PMT': lambda: PMT_decide_on_evacuation(self)
            },
        
        'coping':{
            'CRT': lambda: CRT_decide_on_coping_during_flood(self),
            'SCT': lambda: SCT_decide_on_coping_during_flood(self),
            'TPB': lambda: TPB_decide_on_coping_during_flood(self),
            'PMT': lambda: PMT_decide_on_coping_during_flood(self)
                }
        },
        
    'post_flood': {
        'CRT': lambda: CRT_decide_on_recovery_and_adaptation(self),
        'SCT': lambda: SCT_decide_on_recovery_and_adaptation(self),
        'TPB': lambda: TPB_decide_on_recovery_and_adaptation(self),
        'PMT': lambda: PMT_decide_on_recovery_and_adaptation(self)
    }
}

    # Decide the action type based on perceived severity for each disaster period
    action_mapping = {
        'pre_flood_evac_period': 'evacuation' if self.severity > 0.5 else 'mitigation_preparedness',
        'during_flood': 'evacuation' if self.severity > 0.5 else 'coping'
    }
    
    if self.model.disaster_period in ['pre_flood_evac_period', 'during_flood']:
        action_type = action_mapping[self.model.disaster_period]
        functions = decision_making_functions[self.model.disaster_period][action_type]        
    else:
        functions = decision_making_functions[self.model.disaster_period]
    
    if self.worldview in ['hierarchist', 'fatalist'] and self.bonding_count < 0.3:
        return functions['CRT']()  # Note the function call with ()
    elif (self.past_experience > 0.5) or (self.wealth_class in ("Upper_Middle_Class", "Upper_Class") and self.ethnicity in ['Canadian', 'Immigrant']):
        return functions['PMT']()
    elif (self.social_trust > 0.7 and self.bonding_count > 0.2) or self.wealth_class == "Lower_Class" or self.ethnicity == 'Indigenous':
        return functions['SCT']()
    elif self.self_efficacy > 0.6 and self.social_trust > 0.6:
        return functions['TPB']()
    elif self.wealth_class in ("Upper_Middle_Class", "Upper_Class") or self.education > 0.7:
        return functions['TPB']()
    elif self.bonding_count > 0.6:
        return functions['SCT']()
    # If the period is 'during_flood' or 'post_flood' without specific matches, default to CRT as a general approach
    else:
        return functions.get('CRT')()


#PRE-EVENT

def PMT_decide_on_mitigation_and_preparedness(self):
    # Calculate perceived threat level and coping potential
    threat_level = self.severity * self.vulnerability  + add_randomness() # could this be based on the  flood levels
    coping_potential = self.response_efficacy * self.self_efficacy - self.costs + add_randomness() # could this be based on the predicted levels

    if threat_level > coping_potential + add_randomness():
        self.preflood_non_evacuation_measure_implemented = False
        self.decision_now = "PMT_preflood_mitigation_non_evac_False"
    else:
        self.preflood_non_evacuation_measure_implemented = True
        self.decision_now = "PMT_preflood_non_evacuation_measure_implemented"

 
def TPB_decide_on_mitigation_and_preparedness(self):
    intention = (self.self_efficacy + self.social_trust) / 2 + add_randomness()
    
    if intention > 0.5 + add_randomness():
        self.preflood_non_evacuation_measure_implemented = True
        self.decision_now = "TPB_preflood_non_evacuation_measure_implemented"
    else:
        self.preflood_non_evacuation_measure_implemented = False
        self.decision_now = "TPB_preflood_mitigation_non_evac_False"

def SCT_decide_on_mitigation_and_preparedness(self):
    if  self.social_capital_score > 0.5 + add_randomness():
        self.preflood_non_evacuation_measure_implemented = True
        self.decision_now = "SCT_preflood_non_evacuation_measure_implemented"
    else:
        self.preflood_non_evacuation_measure_implemented = False
        self.decision_now = "SCT_preflood_mitigation_non_evac_False"

def CRT_decide_on_mitigation_and_preparedness(self):

    if self.worldview == 'hierarchist':
        influence_score = min(max(self.income * 0.00001 + 0.5, 0), 1) + add_randomness()
    elif self.worldview == 'egalitarian':
        influence_score = 0.7 if self.bonding_count > 0.8 else 0.4
    elif self.worldview == 'individualist':
        influence_score = 0.9 if self.wealth_class == "Upper_Class" else 0.3
    else:
        influence_score = 0.2 + add_randomness()
    
    if  influence_score > 0.5 + add_randomness():
        self.preflood_non_evacuation_measure_implemented = True
        self.decision_now = "CRT_preflood_non_evacuation_measure_implemented"
    else:
        self.preflood_non_evacuation_measure_implemented = False
        self.decision_now = "CRT_preflood_mitigation_non_evac_False"

         
#PRE-EVENT and DURING-EVENT EVACUATIONS

def PMT_decide_on_evacuation(self):
    immediate_threat = self.severity * 1.2  + add_randomness()  # could this be based on the predicted flood levels
    utility_of_evacuation = immediate_threat - (self.costs * 1.1)  + add_randomness() # could this be based on the predicted flood levels

    if utility_of_evacuation > 0.9 + add_randomness():
        self.evacuated = True
        self.decision_now = "PMT_evacuation"
        
        evac_cost = evac_costs()
        self.income -= evac_cost
        
        business = random.choice(self.model.space.businesses)
        business.wealth += evac_cost/3
        
    else:
        self.evacuated = False
        self.decision_now = "PMT_evac_False"
        
def TPB_decide_on_evacuation(self):
    intention = (self.self_efficacy + self.social_trust) / 2 + add_randomness()
    
    if intention > 0.8 + add_randomness():
        self.evacuated = True
        self.decision_now = "PMT_evacuation"
        
        evac_cost = evac_costs()
        self.income -= evac_cost
        
        business = random.choice(self.model.space.businesses)
        business.wealth += evac_cost/3
        
    else:
        self.evacuated = False
        self.decision_now = "PMT_evac_False"
    
def SCT_decide_on_evacuation(self):
    if  self.social_capital_score > 0.9 + add_randomness():
        self.evacuated = True
        self.decision_now = "PMT_evacuation"
        
        evac_cost = evac_costs()
        self.income -= evac_cost
        
        business = random.choice(self.model.space.businesses)
        business.wealth += evac_cost/3
        
    else:
        self.evacuated = False
        self.decision_now = "PMT_evac_False"
    
def CRT_decide_on_evacuation(self):

    if self.worldview == 'hierarchist':
        influence_score = min(max(self.income * 0.00001 + 0.5, 0), 1)
    elif self.worldview == 'egalitarian':
        influence_score = 0.7 if self.bonding_count > 0.8 else 0.4
    elif self.worldview == 'individualist':
        influence_score = 0.9 if self.wealth_class == "Upper_Class" else 0.3
    else:
        influence_score = 0.2 + add_randomness()
    
    if  influence_score > 0.8 + add_randomness():
        self.evacuated = True
        self.decision_now = "PMT_evacuation"
        
        evac_cost = evac_costs()
        self.income -= evac_cost
        
        business = random.choice(self.model.space.businesses)
        business.wealth += evac_cost/3
            
    else:
        self.evacuated = False
        self.decision_now = "PMT_evac_False"


#DURING EVENT

def PMT_decide_on_coping_during_flood(self):
    threat_level = self.severity * self.vulnerability
    coping_potential = self.response_efficacy * self.self_efficacy - self.costs + add_randomness()
    # Consider the impact of previously implemented mitigation/preparedness measures
    mitigation_effectiveness = 0.8 + add_randomness() if self.preflood_non_evacuation_measure_implemented == True else 0.0

    current_threat_level = threat_level * (1 - mitigation_effectiveness) + add_randomness()
    
    current_coping_potential = coping_potential + (mitigation_effectiveness * 0.5) + add_randomness()

    if current_threat_level > current_coping_potential + add_randomness():
        self.duringflood_coping_action_implemented = False
        self.decision_now = "PMT_duringflood_coping_action_implemented_False"
    else:
        self.duringflood_coping_action_implemented = True
        self.decision_now = "PMT_duringflood_coping_action_implemented_True"

def TPB_decide_on_coping_during_flood(self):
    intention = (self.self_efficacy + self.social_trust) / 2 + add_randomness()
     
    # Consider the effectiveness of previously implemented measures on current intentions
    measure_effectiveness_boost = 0.1 + add_randomness() if self.preflood_non_evacuation_measure_implemented == True else 0.0
    current_intention = intention + measure_effectiveness_boost

    if current_intention > 0.8 + add_randomness():
        self.duringflood_coping_action_implemented = True
        self.decision_now = "TPB_duringflood_coping_action_implemented_True"
    else:
        self.duringflood_coping_action_implemented = False
        self.decision_now = "TPB_duringflood_coping_action_implemented_False"

def SCT_decide_on_coping_during_flood(self):
    mitigation_adjustment = 0.9 + add_randomness() if self.preflood_non_evacuation_measure_implemented == True else -0.1  # Increase or decrease influence based on past decisions
    score = self.social_capital_score + mitigation_adjustment
    
    if  score > 0.5 + add_randomness():
         self.duringflood_coping_action_implemented = True
         self.decision_now = "SCT_duringflood_coping_action_implemented_True"
    else:
         self.duringflood_coping_action_implemented = False
         self.decision_now = "SCT_duringflood_coping_action_implemented_False"
 
def CRT_decide_on_coping_during_flood(self):
    if self.worldview == 'hierarchist':
        influence_score = min(max(self.income * 0.00001 + 0.5, 0), 1)
    elif self.worldview == 'egalitarian':
        influence_score = 0.7 + add_randomness() if self.bonding_count > 0.8 else 0.4
    elif self.worldview == 'individualist':
        influence_score = 0.9 + add_randomness() if self.wealth_class == "Upper_Class" else 0.3
    else:
        influence_score = 0.2 + add_randomness()
    
    if  influence_score > 0.8 + add_randomness():
        self.duringflood_coping_action_implemented = True
        self.decision_now = "CRT_duringflood_coping_action_implemented_True"
    else:
        self.duringflood_coping_action_implemented = False
        self.decision_now = "CRT_duringflood_coping_action_implemented_False"

#POS-EVENT

def PMT_decide_on_recovery_and_adaptation(self):
    # Reflect on the past actions' effectiveness
    mitigation_reflection = 1.0 if self.preflood_non_evacuation_measure_implemented == True else 0.5
    coping_reflection = 1.0 if self.duringflood_coping_action_implemented == True else 0.5

    # Calculate adjusted perceived threat level and coping potential for future events
    future_threat_level = self.severity * self.vulnerability * (1 - mitigation_reflection) + add_randomness()
    future_coping_potential = self.response_efficacy * self.self_efficacy + coping_reflection - self.costs + add_randomness()

    if future_threat_level < future_coping_potential + add_randomness():
        self.postflood_adaptation_measures_planned = False
        self.decision_now = "PMT_postflood_adaptation_measures_planned_False"
    else:
        self.postflood_adaptation_measures_planned = True
        self.decision_now = "PMT_postflood_adaptation_measures_planned_True"

def TPB_decide_on_recovery_and_adaptation(self):
    base_intention = (self.self_efficacy + self.social_trust) / 2
    
    # Adjust intention based on effectiveness of past mitigation/preparedness and coping measures
    past_measures_effectiveness = 0.2 + add_randomness()  if self.preflood_non_evacuation_measure_implemented == True else -0.1  
    past_coping_effectiveness = 0.2 + add_randomness()  if self.duringflood_coping_action_implemented == True else -0.1  

    recovery_intention = base_intention + past_measures_effectiveness + past_coping_effectiveness
    
    if recovery_intention > 0.8 + add_randomness():
        self.postflood_adaptation_measures_planned = True
        self.decision_now = "TPB_postflood_adaptation_measures_planned_True"
    else:
        self.postflood_adaptation_measures_planned = False
        self.decision_now = "TPB_postflood_adaptation_measures_planned_False"
    
def SCT_decide_on_recovery_and_adaptation(self):
     # Adjust intention based on effectiveness of past mitigation/preparedness and coping measures
    past_measures_effectiveness = 0.2 + add_randomness() if self.preflood_non_evacuation_measure_implemented == True else -0.1
    past_coping_effectiveness = 0.2 + add_randomness() if self.duringflood_coping_action_implemented == True else -0.1
    score = self.social_capital_score + past_measures_effectiveness + past_coping_effectiveness
    
    if  score > 0.8 + add_randomness():
         self.postflood_adaptation_measures_planned = True
         self.decision_now = "SCT_postflood_adaptation_measures_planned_True"
    else:
         self.postflood_adaptation_measures_planned = False
         self.decision_now = "SCT_postflood_adaptation_measures_planned_False"
            
def CRT_decide_on_recovery_and_adaptation(self):
    if self.worldview == 'hierarchist':
        influence_score = min(max(self.income * 0.00001 + 0.5, 0), 1)
    elif self.worldview == 'egalitarian':
        influence_score = 0.7 if self.bonding_count > 0.8 else 0.4
    elif self.worldview == 'individualist':
        influence_score = 0.9 if self.wealth_class == "Upper_Class" else 0.3
    else:
        influence_score = 0.2 + add_randomness() 
    
    if  influence_score > 0.8 + add_randomness() :
        self.postflood_adaptation_measures_planned = True
        self.decision_now = "CRT_postflood_adaptation_measures_planned_True"
    else:
        self.postflood_adaptation_measures_planned = False
        self.decision_now = "CRT_postflood_adaptation_measures_planned_False"
        
        
def add_randomness():
    return random.uniform(-0.1,0.1)

def evac_costs():
    return random.uniform(500, 2000)